## Подготовка на собес, после лабы

1. Сверстать простую форму (атрибуты формы, инпутов не забываем)
2. Рассказать как подключают ресурсы на страницу и почему именно так
3. Рассказать про CSS каскад, наследование, специфичность
4. Как работают флексы (или/и гриды)
5. Что такое пост-процессоры
6. Из чего состоит DOM, что это вообще такое, методы для работы с ним, события
7. Дать общее описание JS как языка: парадигмы, типизация, приведение типов, прототипы, контекст исполнения, event loop...
8. Создать простой класс и отнаследоваться от него
9. Рассказать про современные возможности (как синтактический сахар типа rest/spread, так и всякие Promise, async/await)

10. Описать Redux паттерн

11. Решить пару задач на манипуляцию массивами (поиск, сортировка, редьюс, мэп)

12. (-) Написать простую регулярку для работы со строчкой (типа найти доменную зону в адресе сайта)
13. Объяснить что такое юнит-тесты и зачем они

**дополнительно :**

14. http, ответы сервера 0-500

### Структура HTML 5 + как подключают ресурсы на страницу и почему именно так

HTML (HyperText Markup Language (1991) — «язык гипертекстовой разметки»)  
просмотреть - https://developer.mozilla.org/ru/docs/Learn/HTML/%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2_HTML/%D0%9D%D0%B0%D1%87%D0%B0%D0%BB%D0%BE_%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B

основная структура:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Заголовок документа</title>
  </head>
  <body>
    <header><h1>Заголовок</h1></header>
    <main><p>Здесь содержание документа...</p></main>
    <footer></footer>
  </body>
</html>
```

развернутая структура:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- метаданные, шрифты, скрипты -->
    <meta charset="utf-8" />
    <title>Заголовок документа</title>

    <link href="url-font | url-css" rel="stylesheet" />
    <script async|defer src="url"></script>
  </head>
  <body>
    <header>
      <h1>Заголовок</h1>
    </header>
    <main>
      <p>Здесь содержание документа...</p>
      <script>
        script;
      </script>
    </main>
    <footer></footer>

    <script src="url"></script>
  </body>
</html>
```

- подключение скриптов:

в тело документа `body` в теге `<script> код <script>`
либо как внешний файл через `<script src="url"></script>`
`defer` - сохраняет последовательность скриптов (1-2-3). ждёт, пока весь HTML-документ будет готов.
`async` - 1 скрипт - который загрузился быстрее. Запускает скрипты как только они загрузились.

- подключение стилей:

через тег `<style> стили </style>` в head
через тег `<link href="url-css" rel="stylesheet" />` в head
инлавново в тег `style="color: red; font-size: 14px"`

- подключение шрифтов:

через тег `<link href="url-fonts" rel="stylesheet" />` в head
в css `@import url('url');`

---

### Сверстать простую форму (атрибуты формы, инпутов не забываем)

```html
<!-- Простая форма, которая пошлёт POST запрос -->
<form action="?URL" method="get | post">
  <label for="login">Login:</label>
  <input id="login" type="text" name="login" placeholder="login *" required />
  <label for="password">Password:</label>
  <input
    id="password"
    type="password"
    name="password"
    placeholder="password *"
    required
  />
  <!-- <input type="submit" value="submit" /> старый вариант -->
  <button type="submit">Subscribe</button>
</form>
```

<form action="?URL" method="get | post">
  <label for="login">Login:</label>
  <input id="login" type="text" name="login" placeholder="login *" required />
  <label for="password">Password:</label>
  <input
    id="password"
    type="password"
    name="password"
    placeholder="password *"
    required
  />
  <input type="submit" value="submit" />
</form>   
<br>

прим.: fieldset, legend, label

**input types:**

```html
<input type="button" />
<input type="checkbox" />
<input type="color" />
<input type="date" />
<input type="datetime-local" />
<input type="email" />
<input type="file" />
<input type="hidden" />
<input type="image" />
<input type="month" />
<input type="number" />
<input type="password" />
<input type="radio" />
<input type="range" />
<input type="reset" />
<input type="search" />
<input type="submit" />
<input type="tel" />
<input type="text" />
<input type="time" />
<input type="url" />
<input type="week" />
```

post - (использовать, для передачи приватных данных)  
get - (значение по умолчанию, использовать для поисковых запросов как Google)

GET:  
при отправке формы передает собранную информацию как часть URL.  
длина URL-адреса ограничена (2048 символов)  
Никогда не используйте GET для отправки конфиденциальных данных! (будет видно в URL)  
результат можно добавить в закладки  
лучше для незащищенных данных, таких как строки запросов в Google  
POST:  
данные из формы включаются в тело формы и посылаются на сервер.  
не имеет ограничений по размеру и может использоваться для отправки больших объемов данных.

https://developer.mozilla.org/ru/docs/Web/HTML/Element/form  
https://www.w3schools.com/html/html_forms.asp

памятка таблица
https://html5book.ru/html-table

```html
<table>
  <caption>
    caption
  </caption>
  <tr>
    <th>head</th>
    <th>head</th>
  </tr>
  <tr>
    <td>content</td>
    <td>content</td>
  </tr>
  <tr>
    <td colspan="2">итого</td>
  </tr>
</table>
```

---

### ООП

1. Инкапсуляция (черный ящик)

Инкапсуляция — свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе.
Внешний и внутренний интерфейс. Сокрытие внутренней реализации. Приватные и публичные методы.

2. Полиморфизм (набор отверток)

«полиморфизмом» — свойство системы, позволяющее использовать объекты с одинаковым интерфейсом
разные фигуры (объекты) + одинаковый метод заливка (одинаковый интерфейс)

3. Наследование (матрешка)

Наследование — свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.
Последовательеное наследование от нескольких классов.

4. Абстрагирование (выделение главного)

Абстрагирование - означает выделение значимой информации и исключение из рассмотрения незначимой.

- термины:

class - создание нового класса/модели.  
method - функция внутри класса.  
constructor() - метод, который инициирует объект при создании экземпляра класса.  
extends - используется для определения наследования.  
super() - метод, который устанавливает свойства наследования за счет вызова родительского конструктора. Метод super должен стоять первой строкой в методе constructor.  
new - создание объекта через метод конструктора класса.

---

### Рассказать про CSS каскад, наследование, специфичность

«Cascading Style Sheets» или «каскадные таблицы стилей».

- наследование - https://htmlacademy.ru/courses/66/run/2

наследуемые - параметры отображения текста  
ненаследуемые - параметры позиционирования, размеров, отступов, фона, рамок - https://htmlacademy.ru/courses/307/run/6

- каскадирование - https://htmlacademy.ru/courses/66/run/8

важность - сравнивание приоритетов  
специфичность - 0 0 0 0 0 0 0 0  
(0 0 0 0 !important), инлайн, id, class, tag  
порядок исходного кода - последний перекрывает все предыдущие

**Каскадность (перекрытие)** обозначает, что к одному и тому же элементу может применяться несколько CSS-свойств. Почему каскад: поток водопада и каскадов, поток идет поверху и перекрывает все нижние ступени.

**Одиночные теги**, называют пустыми тегами, они не могут содержать текста или других тегов между открывающим и закрывающим тегами. В одиночных тегах можено использовать закрывающий тег и это не будет ошибкой

```html
<img></img>
<br></br>
<input></input>
// памятка
<img src="pic_trulli.jpg" alt="Italian Trulli">
```

### Как работают флексы (или/и гриды)

- флексы - https://wp-kama.ru/id_8045/flex-v-css.html
- гриды - https://wp-kama.ru/id_8945/grid-v-css.html

```scss
.grid: {
  display: grid;
  grid-template-rows: 50px 50px;
  grid-template-columns: 50px 50px;
}
.item: {
  grid-row: 2;
  grid-column: 1 / span 2;
}
```

---

### Что такое ПОСТ-процессоры

ПРЕпроцессор — это программа, которой на вход дается код написанный на языке препроцессора, а на выходе мы получаем CSS.  
Sass(.sass, .scss), Less(.less) и Stylys(.stylus).
https://sass-scss.ru/guide/

- Переменные
- Вложенности
- Фрагментирование. Фрагмент — это простой Sass-файл, имя которого начинается с нижнего подчеркивания `_color.scss`. Нижнее подчеркивание Sass-файла говорит компилятору что это фрагмент и он не должен компилироваться в CSS.
- Импорт - @import - на выходе получается один CSS-файл
- Миксины (примеси)
- Расширение/Наследование
- Математические операторы

```scss
// Переменные
$color: #333;
body {
  color: $color;
}
// Вложенности
ul {
  li {
    color: red;
  }
}
// Миксин
li {
  @include mixin(white, blue);
}
@mixin mixin($link, $hover) {
  a {
    color: $link;
    &:hover {
      color: $hover;
    }
  }
}
// Расширение/Наследование
%shared {
  color: #333;
}
.message {
  @extend %shared;
}
// Математические операторы
p {
  color: #010203 * 2;
}
// доп.фн с цветом
p {
  color: lighten($color, 40%);
}
```

ПОСТпроцессор — это программа на вход которой дается `css`, а на выходе получается `css`. - https://habr.com/ru/post/434098/  
**PostCSS** — единственны ПОСТпроцессор в контексте css.  
**Плагины:**

Autoprefixer - добавляет браузерные (вендорные) префиксы к вашим правилам.  
PostCSS Auto Reset - позволяет нам не создавать отдельный файл со сбросом всех стилей.  
PostCSS Preset Env - директива @custom-media, функция color-mod.

---

### Из чего состоит DOM, что это вообще такое, методы для работы с ним, события

DOM (Document Object Model)  
Document Object Model, сокращённо DOM – <b>объектная модель документа</b>, все содержимое страницы в виде объектов.  
`document` – основная «входная точка»

```js
document.body.style.background = "red";
```

![](https://coursehunters.online/uploads/default/original/1X/c20c66f6faeadf5df74b86cecd823353d0f17a80.jpeg)

![](https://cf2.ppt-online.org/files2/slide/d/DNFnoZOuqmBJAjir2yS69PvEKe17bpW3LsQMXxHlTd/slide-12.jpg)

BOM (Browser Object Model)  
Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.  
navigator.userAgent – информация о текущем браузере  
navigator.platform – информация о платформе

- https://learn.javascript.ru/browser-environment
- https://learn.javascript.ru/dom-nodes
  <br>
- https://learn.javascript.ru/dom-navigation
- https://learn.javascript.ru/searching-elements-dom

![](https://camo.githubusercontent.com/57661361003a2a13a65d59ee8ad3e582a779ed5a/687474703a2f2f6a6176617363726970742e696e666f2f61727469636c652f646f6d2d6e617669676174696f6e2f646f6d2d6c696e6b734032782e706e67)

---

![](https://javascript.info/article/dom-navigation/dom-links-elements@2x.png)

Разница между Node и Element - Node содержит более полную информацию, которая не всегда нужна. Для выборки и переходов использовать element.

Селекторы:

```JS
const element = document.getElementById('elementChildNode');
const elements = document.querySelectorAll('ul > li');

const inputs = table.getElementsByTagName('input');
// elem.getElementsByClassName(className) // arr
// document.getElementsByName(name) // arr
const element = elem.querySelector('footer');
```

Навигационные ссылки.  
Для всех узлов: `parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling`  
Только для узлов-элементов: `parentElement, children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling`

- Читать про DOM методы вставки, удаления, клонирования:
  https://learn.javascript.ru/modifying-document#sozdanie-elementa

```js
let div = document.createElement("div");
div.className = "alert";
div.innerHTML = "Всем привет!";
// div.remove(); // удаление
// div.append(elem); // добавление элемента вконец
// div.prepend(elem); // вначало. (см.рис)
```

![](https://learn.javascript.ru/article/modifying-document/before-prepend-append-after.svg)

- **elem.cloneNode(true)** - клон элемента с дочерними элементами
- **elem.cloneNode(false)** - клон БЕЗ дочерних элементов
  https://www.w3schools.com/jsref/met_node_clonenode.asp

```js
const item = document.getElementById("List").lastChild;
const clon = item.cloneNode(true);
document.getElementById("List").appendChild(clon);
```

append vs appendChild
https://developer.mozilla.org/ru/docs/Web/API/ParentNode/append

Отдельный пример - DocumentFragment(), вставляет содержимое

```JS
<ul id="ul"></ul>

<script>
function getListContent() {
  let fragment = new DocumentFragment();
  for(let i=1; i<=3; i++) {
    let li = document.createElement('li');
    li.append(i);
    fragment.append(li);
  }
  return fragment;
}
  ul.append(getListContent());
</script>
```

по аналогии, только проще

```JS
<ul id="ul"></ul>

<script>
function getListContent() {
  let result = [];
  for(let i=1; i<=3; i++) {
    let li = document.createElement('li');
    li.append(i);
    result.push(li);
  }
  return result;
}
  ul.append(...getListContent());
</script>
```

---

### Дать общее описание JS как языка: парадигмы, типизация, приведение типов, прототипы, контекст исполнения, event loop...

Общее про JS - https://learn.javascript.ru/intro  
изначально LiveScript  
Брендан Айк 1995  
Спецификация: ECMAScript  
Движки: v8, spiderMonkey

Парадигмы: ООП и ФП (нет практики).  
Типизация: слаботипизированный язык программирования.  
примитивы: n, s, b, n, u;  
object;  
symbol для уникальных идентификаторов;  
Является реализацией языка ECMAScript.

приведение типов: явное и НЕявное.

- преобразование:

```js
String(value), Number(value), Boolean(value) // явное
Number('123') // явное
+'123' // неявное
123 != '456' // неявное
4 > '5' // неявное
5/null // неявное
true | 0 // неявное
Boolean(2) // явное
if (2) { ... } // неявное в логическом контексте
!!2// неявное  логическим оператором
2 || 'hello'// неявное логическим оператором
String(123) // явное
123 + ''// неявное
```

как посмотреть свойства функции

```js
function fun() {
  const a = 1;
}
console.dir(fun);
// ƒ fun()
// length: 0
// name: "fun"
// arguments: null
// caller: null
// prototype: {constructor: ƒ}
// __proto__: ƒ ()
const funA = () => (a = 1);
console.dir(funA);
// funA()
// arguments: (...)
// caller: (...)
// length: 0
// name: "funA"
// __proto__: ƒ ()
```

Цепочка прототипов 
![](https://learn.javascript.ru/article/native-prototypes/native-prototypes-classes.png)

- event loop

![](https://camo.githubusercontent.com/08036d0d7e012c5e46634ddeda173bbfe555c817/687474703a2f2f692e696d6775722e636f6d2f71695a746e48762e676966)
![](https://camo.githubusercontent.com/997fca616f4bca674d439ed7c8e235277dacbb87/687474703a2f2f692e696d6775722e636f6d2f436e6473326b732e676966)

![](https://cdn-images-1.medium.com/max/1100/1*FlRpHWcd2XM_86Ia3FL3EQ.gif)

- глобальный контекст | контекст выполнения функции

```js
// глобальный контекст выполнения
var hello = "Hello";
var user = function() {
  // контекст выполнения функции
  var name = "John Smith";
  var getName = function() {
    // контекст выполнения функции
    return name;
  };
  var sayHello = function() {
    // контекст выполнения функции
    console.log(hello + ", " + getName());
  };
  sayHello();
};
user(); //Hello, John Smith
```

![img](https://assets.htmlacademy.ru/img/blog/195/global-execution-context@1x.png)

- What is this?

Ключевое слово this - всегда динамичное.  
Оно указывает на тот **объект** в контексте которого оно было вызвано.

```js
Контекст - окружение исполнения.
function whereIsThis() {
  console.log('this :', this);
}
const myObject = {
  nameObject: 'myObject',
  runThis: whereIsThis
}
// тут вызовем из глобального контекста
whereIsThis(); // this : Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}
// а тут вызовем из объекта
myObject.runThis(); // this : {nameObject: "myObject", runThis: ƒ}
```

**this** это ссылка на - объект (элемент) в котором произходит вызов (действие, событие).  
https://getinstance.info/articles/javascript/execution-context/

- прототипы

[10. Prototype. Differences between `__proto__` and prototype. Example of inheritance.](#10-prototype-differences-between-__proto__-and-prototype-example-of-inheritance)

https://learn.javascript.ru/prototype

```js
const animal = { eats: true };
const rabbit = { jumps: true };
rabbit.__proto__ = animal; // ссылка на прототип
// в rabbit можно найти оба свойства
console.log(rabbit.jumps); // true
console.log(rabbit.eats); // true
```

---

### Создать простой класс и отнаследоваться от него

https://learn.javascript.ru/es-class  
**class** – удобный «синтаксический сахар» для задания конструктора вместе с прототипом.

```js
class Название [extends Родитель]  {
  constructor(){
    super(); // если наследовались
    методы
  }
}
```

```js
class Animal {
  constructor(name, voice) {
    this.name = name;
    this.voice = voice;
  }
  say() {
    console.log(` ${this.name} voice ${this.voice}`);
  }
}
class Bird extends Animal {
  constructor(name, voice) {
    super(name, voice);
    super.say(); // можем вызвать метод родителя
  }
  // добавляем новый метод
  canFly() {
    console.log(`Птица может летать`);
  }
  // переопределение метода
  say() {
    console.log(`Прицы не любят разговаривать`);
  }
}
const duck = new Bird("Утка", "кря-кря");
duck.say();
duck.canFly();
```

Подробней:  
[10. Prototype. Differences between `__proto__` and prototype. Example of inheritance.](#10-prototype-differences-between-__proto__-and-prototype-example-of-inheritance)

### Рассказать про современные возможности (как синтактический сахар типа rest/spread, так и всякие Promise, async/await)

let, const  
arrow function : (a,b)=>{ }  
default parametrs : fn( a=1, b=2 ){ }  
rest parametr : fn ( a, b, ...args ){ }  
spread operator : { }={ ...{ }, ...{ } }  
деструктуризация : const{ a,b }=obj
template strings : `text \${x} text``

цепочки промисов - https://learn.javascript.ru/promise-chaining
промис - https://learn.javascript.ru/promise
async-await - https://learn.javascript.ru/async-await

```js
const promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve("done"), 1000);
});
promise
  .then(data => data + 1)
  .then(data => data + 2)
  .then(data => setTimeout(() => console.log(data + 3), 3000)); // done123
```

```js
// promis + fetch
(function loadJson() {
  return fetch(
    "https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json"
  )
    .then(response => response.json())
    .then(data => console.log(JSON.stringify(data)));
})();
```

```js
// async/await + fetch
(async function foo() {
  const response = await fetch(
    "https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json"
  );
  const json = await response.json();
  console.log(JSON.stringify(json));
})();
```

---

### Описать Redux паттерн (шаблон проектирования)

Redux — библиотека управления состоянием для приложений, написанных на JavaScript.

Она помогает писать приложения, которые ведут себя стабильно/предсказуемо, работают на разных окружениях (клиент/сервер/нативный код) и легко тестируемы.

https://getinstance.info/articles/react/learning-react-redux/ - эта статья

Redux предлагает хранить **все состояние приложения в одном месте**, называемом **«store»** («хранилище»). Компоненты «отправляют» изменение состояния в хранилище, а не напрямую другим компонентам. **Компоненты**, которые должны быть в курсе этих изменений, **«подписываются» на хранилище**.

![](https://getinstance.info/upload/medialibrary/4e4/4e42f026ab5cdc7c9f31b5b374cb9ac1.png)

Хранилище может рассматриваться как «посредник» во всех изменениях состояния в приложении. С Redux компоненты не связываются друг с другом напрямую, все изменения должны пройти через единственный источник истины, через хранилище.

![](https://getinstance.info/upload/medialibrary/ba4/ba494148d28e422b4c7bd269de5bed09.png)

C Redux все компоненты получают свое состояние из хранилища. Также ясно, куда компонент должен отправить информацию об изменении состояния — опять же в хранилище. Компонент только инициирует изменение и не заботится об остальных компонентах, которые должны получить это изменение. Таким образом, Redux делает поток данных более понятным.

**три основных принципа Redux:**

1. Единственный источник истины

Redux использует только **одно хранилище** для всего состояния приложения. Поскольку состояние находится в одном месте, его называет **единственным источником истины**.

2. Состояние доступно только для чтения

Согласно документации Redux, «Единственный способ изменить состояние — передать **экшен (action)** - объект, описывающий, что произошло».

Это означает, что приложение не может напрямую изменить состояние. Вместо этого, необходимо передать «action», чтобы выразить намерение изменить состояние в хранилище.

3. Изменения делаются «чистыми» функциями

Итак, Redux не позволяет изменять состояние напрямую. Вместо это экшен описывает, какие изменения необходимо сделать. **Редьюсеры** (reducers) — это функции, которые обрабатывают экшены и могут вносить изменения в состояние.

**Редьюсер принимает текущее состояние в качестве параметра.**

Редьюсеры должны быть реализованы как “чистые” функции (pure functions), термин, описывающий функции, удовлетворяющие следующим условиям:

**Они не должны** делать внешних вызовов по сети или базе данных.  
**Они возвращают** значение, зависящее только от переданных параметров.  
**Их аргументы** являются неизменяемыми, т.е. функции не должны их изменять.
**Вызов** чистой функции с теми же аргументами всегда возвращает одинаковый результат.

**Чистая функция:**  
-результат вызова зависит только от аргументов
-нет сторонних эфектов

![](https://linkites.com/wp-content/uploads/2018/07/poster-105.gif)

---

### Решить пару задач на манипуляцию массивами (поиск, сортировка, редьюс, мэп)

смотри: [12. array methods that loop over the elements](#12-array-methods-that-loop-over-the-elements)

---

### Написать простую регулярку для работы со строчкой (типа найти доменную зону в адресе сайта)

https://www.exlab.net/tools/sheets/regexp.html  
скачать и учить - https://www.exlab.net/files/tools/sheets/regexp/regexp.pdf

```js
//валидация формы только A-z
/^[A-z,\s]+$/ // только A-z
/^[A-z,0-9\s]+$/ // только A-z + 0-9
```

```js
"https://developer.mozilla.org"
  .match(/\p{P}\w{1,3}\//iu)
  .join()
  .slice(1, -1);
```

https://learn.javascript.ru/regular-expressions

---

### Объяснить что такое юнит-тесты и зачем они

Unit-тестирование (англ. unit testing / модульное тестирование) - это проверка корректности работы отдельных частей приложения в изолированной среде независимо друг от друга.
На практике unit-тесты пишутся:  
**для сложных функций**, чтобы запускать их при внесении изменений в исходный код проекта,  
**для выявления регрессионных ошибок**.

_Регрессионная ошибка_ - ошибка, которая возникает в при внесении изменений в другой части приложения.

Для unit-тестирования в Angular используется фреймворк Jasmine.
Angular CLI по умолчанию устанавливает все инструменты для unit-тестирования - **ng test**  
Команда собирает приложение и запускает тесты. Файлы тестов должны быть в формате **\*.spec.ts**.  
ng test запустит браузер, с результами тестирования, отчет дублируется в консоль.

структура теста:

```js
import {...} from '...';
...
describe('related tests group', () => {
  beforeEach(() => {...});
  it('test description', async(() => {
  expect(...).toBe(...);
}));
...
});
```

Сперва импортируются зависимости элементы библиотеки **@angular/core/testing**  
Далее описываются сами тесты.  
**describe()** объединяет группу тестов. Первым параметр - текстовое описание группы, второй - функция - конфигурацию и набор тестов.  
**describe()** описывает тест функцией **it()**.  
**it()** принимает текстовое описание и функцию с описанием логики.  
Проверка результата осуществляется с помощью функции **expect()**, принимающей итоговое значение, в связке с одной из функций соответствия

```js
it("expect example", () => {
  let a = 5;
  a = a + 7;
  expect(a).toBe(12);
});
```

**beforeEach()** используется для задания исходного состояния и вызывается перед каждой функцией **it()**.

```js
beforeEach(async(() => {
  TestBed.configureTestingModule({
    declarations: [AppComponent]
  }).compileComponents();
}));
```

---

### http, ответы сервера 0-500

Протокол передачи гипертекста (**HyperText Transfer Protocol** - HTTP) - это прикладной протокол для передачи гипертекстовых документов, таких как HTML. Он создан для связи между веб-браузерами и веб-серверами.

HTTP протокол - клиент-серверного взаимодействия, инициирование запросов к серверу веб-браузером. Полученный документ может состоять из различных поддокументов: полученного текста, описания структуры документа, изображений, видео-файлов, скриптов и многого другого.

![](https://media.prod.mdn.mozit.cloud/attachments/2016/08/09/13677/d031b77dee83f372ffa4e0389d68108b/Fetching_a_page.png)

https://developer.mozilla.org/ru/docs/Web/HTTP  
https://developer.mozilla.org/ru/docs/Web/HTTP/Overview

1xx — информационные коды. Запрос принят и обработка будет продолжаться.  
2xx — успешная обработка. Запрос получен и успешно обработан сервером.  
3xx — перенаправление (редирект).  
4xx — ошибка пользователя.  
5xx — ошибка сервера.  
https://netpeak.net/ru/blog/otvety-servera-podrobnaya-instruktsiya/

основные status code:  
200 ОК - запрос выполнен успешно  
301 Moved Permanently - перемещено навсегда  
302 Found - временно перенесено на другой адрес  
304 Not Modified - Не Изменено, инфа для поисвовиков  
403 Forbidden - Отказано в доступе (входе с запрещенных IP)  
404 Not Found - ничего не найдено  
410 Gone - документ удален  
451 Unavailable For Legal Reasons - доступ закрыт на государственном уровне или по решению суда в случае нарушения авторских прав  
500 Internal Server Error - внутренняя ошибка сервера  
503 Service Unavailable - сервер временно не может обрабатывать запросы по техническим причинам  
504 Gateway Timeout - Время ответа сервера истекло

---

<details>
<summary>Question examples... ↴</summary>

1. Data types in JS. Type coercion.
2. What is hoisting?
3. Let vs var. Const.
4. Passing data by value and by reference. Exapmles.
5. `{a: 10} == {a: 10}`. What will the code return?
6. What is `this`?
7. Apply, call, bind. What are they used for? What are the differences?
8. Closure. Give an example.
9. Sum(1)(2);
10. Prototype. Differences between `__proto__` and `prototype`. Example of inheritance.
11. How to create an object without a prototype?
12. Array methods that loop over the elements.
13. `“hello world”.repeating(3)` -> `hello world hello world hello world`. How to implement?
14. Browser events. Browser default actions abortion.
15. Event bubbling and event capturing.
16. Event delegation. Example.
17. Write a function `F` so `new F === F`
18. `Function.prototype.bind` polyfill.
19. `Object.create` polyfill.
20. Event loop.
21. Promises.
    Стрелочная функция + this

Full name and contacts of the mentor who will interview you can be found in this

### Passing the interview

1. You should contact the mentor personally. Contact details will be announced through Discord.
2. At the request of the mentor, the interview can take place online or face-to-face.
3. During the interview mentor:

- asks questions;
- gets answers;
- adds/corrects/explains/gives the right answer, if necessary.

### The interview should be passed before 16 June 2019. Take into account that mentor can be busy (vacation, business trip, workload and etc.), so contact him as soon as possible.

Ссыка на таск: https://github.com/rolling-scopes-school/tasks/blob/2018-Q3/tasks/interview-corejs.md

Контакты ментора: http://app.rs.school/mentor-contacts?course=rs-2019-q1

</details>

## Ответы:

Руководство по написанию JavaScript-кода от Airbnb:  
https://github.com/airbnb/javascript  
https://github.com/leonidlebedev/javascript-airbnb (rus)
[Вопросы и ответы к собеседованию фронтенд-разработчика на JavaScript](https://medium.com/@allaev/%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B-%D0%B8-%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%8B-%D0%BA-%D1%81%D0%BE%D0%B1%D0%B5%D1%81%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8E-%D1%84%D1%80%D0%BE%D0%BD%D1%82%D0%B5%D0%BD%D0%B4-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B0-%D0%BD%D0%B0-javascript-9058a75710a)

### 1. Data types in JS. Type coercion.

В JavaScript есть 7 основных типов: <b>number, string, boolean, null, undefined, object, symbol</b>
<b>number</b> для любых чисел: целочисленных или чисел с плавающей точкой.
<b>string</b> для строк. Строка может содержать один или больше символов, нет отдельного символьного типа.
<b>boolean</b> для true/false.
<b>null</b> для неизвестных значений – отдельный тип, имеющий одно значение null.
<b>undefined</b> для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
<b>object</b> для более сложных структур данных.
<b>symbol</b> для уникальных идентификаторов.

Оператор <b>typeof()</b> позволяет нам увидеть, какой тип данных сохранён в переменной. Имеет две формы: typeof x или typeof(x).  
Возвращает строку с именем типа. Например, "string".
Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.

для определения типа оператор - [typeof(x)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/typeof)

Type coercion.  
Тип принуждения (Оказание давления) (Приведение типов данных)  
<a name="type_coercion"></a>
![img](https://pbs.twimg.com/media/Cuaymi4UEAAVi2d.jpg)  
Тип принуждения означает, что, когда операнды оператора являются разными типами, один из них будет преобразован в "эквивалентное" значение другого типа операнда.  
Например: boolean == integer.  
Логический операнд будет преобразован в целое число: false становится 0, true становится 1.

https://learn.javascript.ru/types-intro  
http://qaru.site/questions/86563/what-exactly-is-type-coercion-in-javascript

---

### 2. What is hoisting?

Что такое подъем? <br>
Поднятие или hoisting — это механизм в JavaScript в котором переменные и объявления функций передвигаются вверх своей области видимости перед тем, как код будет выполнен.

ES 5

```JS
console.log(a); // undefined
var a = 7;
console.log(a); // 7
a = 5;
console.log(a); // 5
```

ES 6

```JS
console.log(b); // b is not defined
let b = 7;
```

```JS
let a = 1;
function hoisting(){
   let a = 2; // объявление внутри функции
   console.log(a); // 2
}
hoisting();
console.log(a); // 1
```

```JS
let a = 1;
function hoisting(){
   a = 2; // переопределение значения
   console.log(a); // 2
}
hoisting();
console.log(a); // 2
```

[Поднятие](https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%9F%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5) <br>
[Разбираемся с “поднятием” (hoisting) в JavaScript](https://medium.com/@stasonmars/%D1%80%D0%B0%D0%B7%D0%B1%D0%B8%D1%80%D0%B0%D0%B5%D0%BC%D1%81%D1%8F-%D1%81-%D0%BF%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5%D0%BC-hoisting-%D0%B2-javascript-7d2d27bc51f1) <br>
[Область видимости в JavaScript и «поднятие» переменных и объявлений функций - habr.com/ru/post/127482](https://habr.com/ru/post/127482/)

True JS 5. Hoisting - https://www.youtube.com/watch?v=e6YB6ehg5g8  
True JS 21. Области видимости внутри функции, hoisting - https://www.youtube.com/watch?v=3UXqvjmJkA0

тут есть задачи - http://jsflow.org/docs/create-exec-phase/

---

### 3. Let vs Var. Const.

Объявление <b>const</b> задаёт константу, то есть переменную, которую нельзя менять:

```JS
const apple = 5;
apple = 10; // ошибка
```

У объявлений переменной через <b>let</b> есть три основных отличия от <b>var</b>:

1. Область видимости переменной <b>let</b> – блок {...}

```JS
var apples = 5;
if (true) {
  var apples = 10;
  alert(apples); // 10 (внутри блока)
}
alert(apples); // 10 (снаружи блока то же самое)
```

```JS
let apples = 5; // (*)
if (true) {
  let apples = 10;
  alert(apples); // 10 (внутри блока)
}
alert(apples); // 5 (снаружи блока значение не изменилось)
```

```JS
if (true) {
  let apples = 10;
  alert(apples); // 10 (внутри блока)
}
alert(apples); // ошибка!
```

2. Переменная <b>let</b> видна только после объявления.

```JS
alert(a); // undefined
var a = 5;
```

```JS
alert(a); // ошибка, нет такой переменной
let a = 5;
```

```JS
let x;
let x; // ошибка: переменная x уже объявлена
```

3. При использовании в цикле, для каждой итерации создаётся своя переменная.  
   Переменная <b>var</b> – одна на все итерации цикла и видна даже после цикла:

```JS
for(var i=0; i<10; i++) { /* … */ }
alert(i); // 10
```

Каждому повторению цикла соответствует своя независимая переменная <b>let</b>.

```JS
// каждый цикл имеет свою переменную i
for(let i = 0; i<10; i++) { /* … */ }
alert( i ); // ошибка: глобальной i нет
```

https://learn.javascript.ru/let-const  
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/let

---

### 4. Passing data by value and by reference. Exapmles.

Передача данных по значению и по ссылке. Примеры.

<b>number, string, boolean</b> - передаются по значению, функция получает копию данного значения.

```JS
let a = 5, b = 7;
b = a;
console.log(a, b); // 5 5
a = 4;
console.log(a, b); // 4 5
```

```JS
let a = 'a', b = 'b';
b = a;
console.log(a, b); // a a
a = 'a2';
console.log(a, b); // a2 a
```

<b>object, array</b> - передаются по ссылке. <br>

```JS
let user = { name: "Вася" }; // в переменной - ссылка на объект
let admin = user; // скопировали ссылку
console.log(user, admin, admin.name); // {name: "Вася"} {name: "Вася"} "Вася"
admin.name = 'Сеня'; // передаем новое значение
console.log(user.name); // Сеня
```

Клонирование объектов

```JS
let user = { name: "Вася", age: 30 };
let clone = {};
for (let key in user) {
   clone[key] = user[key];
}
clone.name = "Петя";
// user {name: "Вася", age: 30}
// clone {name: "Петя", age: 30}
```

Копирование Array по ссылке

```JS
let arr1 = ['a','b'];
let arr2 = arr1;
arr2.push('c');
console.log(arr1, arr2); // ["a", "b", "c"] ["a", "b", "c"]
```

Копирование Array по значению

```JS
let arr1 = ['a','b'];
let arr2 = [...arr1];
arr2.push('c');
console.log(arr1, arr2); // ["a", "b"] ["a", "b", "c"]
```

https://metanit.com/web/javascript/3.7.php  
https://learn.javascript.ru/object-reference  
http://qaru.site/questions/10741/copying-array-by-value-in-javascript

---

### 5. {a: 10} == {a: 10}. What will the code return?

false  
потому что это объект, объект не сравнивается ни с чем ([см.Таблица сравнения типов](#type_coercion)).

---

### 6. What is `this`?

1. Ключевое слово <b>this</b> - всегда динамичное.
2. Оно указывает на <b>тот объект</b> в контексте которого оно было вызвано.  
   <b>Контекст</b> - окружение исполнения.

```JS
function whereIsThis() {
  console.log('this :', this);
}
let myObject = {
  nameObject: 'myObject',
  runThis: whereIsThis
}
// тут вызовем из глобального контекста
whereIsThis(); // this : Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}
// а тут вызовем из объекта
myObject.runThis(); // this : {nameObject: "myObject", runThis: ƒ}
```

<b>this это ссылка на - объект (элемент) в котором произходит вызов (действие, событие)</b>.

https://www.youtube.com/watch?v=UGapN-hrekw  
https://www.youtube.com/watch?v=PBI5hEnMStc

http://qaru.site/questions/1228/how-does-the-this-keyword-work  
https://learn.javascript.ru/object-methods  
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this

---

### 7. Apply, call, bind. What are they used for? What are the differences?

Применить, звать, связать. Для чего они используются? Какие есть отличия?

Все три функции являются методами (функциями, прикрепленными к объекту функции),
которые вызывают функцию с заданым (установленным, кастомным) this контекстом.

**call** - вызов функции с подменой контекста - this внутри функции  
**apply** - вызов функции с переменным количеством аргументов и с подменой контекста  
**bind** - создаёт "обёртку" над функцией, которая подменяет контекст этой функции

```JS
    let car1 = { model: 'Renault' }
    let car2 = { model: 'BMW' }
    function showDetails(color, price) {
      console.log(`${this.model} ${color} ${price}$`);
    }

    let bound = showDetails.bind(car1, 'yellow', 100);
    bound(); // Renault yellow 100$
    bound = showDetails.bind(car2);
    bound('white', 200); // BMW white 200$

    showDetails.call(car1, 'red', 300); // Renault red 300$
    showDetails.apply(car2, ['green', 400]); // BMW green 400$
```

https://www.youtube.com/watch?v=OaR9Go75hOY  
https://www.youtube.com/watch?v=UGapN-hrekw

https://sneakbug8.ru/bind-vs-apply-and-call  
[medium.com/@stasonmars/подробно-о-методах-apply-call-и-bind-необходимых-каждому-javascript-разработчику-ddd5f9b06290](https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%BE-%D0%BE-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0%D1%85-apply-call-%D0%B8-bind-%D0%BD%D0%B5%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B8%D0%BC%D1%8B%D1%85-%D0%BA%D0%B0%D0%B6%D0%B4%D0%BE%D0%BC%D1%83-javascript-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D1%83-ddd5f9b06290)  
https://ru.stackoverflow.com/questions/426699/bind-call-apply-%D0%B2-%D1%87%D1%91%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0

---

### 8. Closure. Give an example.

**Замыкание** - это функция ссылающаяся на (free variabl) свободную переменную, объявленную вне этой функции.  
Функция = блок кода + набор доступных переменных, также надо учитывать окружение фукнции.  
**Замыкания** - это функции, ссылающиеся на независимые (свободные) переменные (free variables).  
Независимые переменные (**free variables**) - это все переменные,
которые не были переданы как параметры и не были объявлены как локальные. Другими словами, функция, определённая в замыкании, «запоминает» окружение, в котором она была создана.

```JS
// глобальный контекст выполнения
let c = 10; // глобальная переменная, для примера
function count() {
  // контекст функции count() - это обертка
  let c = 0; // Локальная «свободная» переменная (free variable), которая попадает в замыкание
  function operation() { // контекст функции operation()
  // function operation() - является замыканием, т.к. использует переменную 'с' объявленную вне этой функции
    c++;
    return c; // возвращаем значение
  }
  return operation;
}
const countFirst = count();
const countSecond = count();
console.log('countFirst: ', countFirst(), countFirst(), countFirst()); // countFirst:  1 2 3
console.log('countSecond: ', countSecond(), countSecond()); // countSecond:  1 2
console.log('c :', c); // c : 10
```

Пример контекста и независимых переменных  
![img](https://assets.htmlacademy.ru/img/blog/195/global-execution-context@1x.png)

https://www.youtube.com/watch?v=BIHziPMbaJw
https://www.youtube.com/watch?v=RPuFz93Gvpk  
https://www.youtube.com/watch?v=UsFPvkWeUgw  
https://www.youtube.com/watch?v=2zQapitrXSY

https://medium.com/@sshambir/%D0%BE%D1%81%D0%B2%D0%B0%D0%B8%D0%B2%D0%B0%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-5b83267ef7d1
https://htmlacademy.ru/blog/useful/javascript/lets-learn-javascript-closures  
https://learn.javascript.ru/closures  
https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures  
https://habr.com/ru/post/38642/  
https://medium.com/webbdev/closures-9a20e84b62cd

---

### 9. Sum(1)(2);

```JS
sum(1)(2); // 3
function sum(a) {
  return function(b) {
    return a + b;
  };
}
```

<details>
<summary>умные решения... ↴</summary>

```JS
// пример замыкания из википедии
const add = x => y => {
  const z = x + y;
  console.log(x + '+' + y + '=' + z);
  return add(z);
};
const res = add(1)(4)(6);
// 1+4=5
// 5+6=11
```

```JS
// умное универсальное решение
function sum(...params) {
  let s = params.reduce((a, b) => a + b);
  function innerSum(...innerParams) {
    return sum(...innerParams.concat(s));
  };
  innerSum.toString = innerSum.valueOf = function() {
    return s;
  }
  return innerSum;
}
console.log(sum(1, 2)(3, 4)(5, 6));
console.log(sum(1)(2)(3)(4)(5)(6));
console.log(sum(1)(2, 3)(4, 5, 6));
```

</details>

[Преобразование объектов: toString и valueOf - learn.javascript.ru/object-conversion](https://learn.javascript.ru/object-conversion) <br>
[Метод valueOf() возвращает примитивное значение указанного объекта.](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf)  
[Метод toString() возвращает строку, представляющую исходный код функции.](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/toString)

https://stackoverflow.com/questions/5832891/variadic-curried-sum-function  
http://qaru.site/questions/218785/variadic-curried-sum-function

---

### 10. Prototype. Differences between `__proto__` and `prototype`. Example of inheritance.

Прототип. Различия между `__proto__` и `prototype`. Пример наследования.

Чтобы разобраться сделаем объект и посмотрим что внутри:

```JS
let foo = {
  x: 10,
  y: 20
};
foo;
/*
{x: 10, y: 20} ↴
x: 10
y: 20
__proto__: Object // Вот оно, неявное свойство
которое ссылается на верховный объект-прототип
*/
```

![](http://dmitrysoshnikov.com/wp-content/uploads/basic-object.png)

В каждом объекте есть набор явных свойств и одно неявное свойство - `__proto__` которое ссылается на другой верховный объект-прототип. Прототип может быть либо объектом, либо null значением.

Если прототип не указан явно для объекта, то `__proto__` принимается значение по умолчанию - Object.prototype. Object.prototype - это объект который также имеет свойство `__proto__`, является конечным звеном цепи прототипов и имеет значение null.

```JS
let a = {
  x: 10,
  calculate: function (z) {
    return this.x + this.y + z;
  }
};
let b = {
  y: 20,
  __proto__: a
};
let c = {
  y: 30,
  __proto__: a
};
b.calculate(30); // 60
c.calculate(40); // 80
```

![](http://dmitrysoshnikov.com/wp-content/uploads/prototype-chain.png)

<details>
<summary>Холмс что-же такое prototype? ...элементарно Ватсон!</summary>

![](http://img.playground.ru/images/7/8/229166_elementarno-vatson.jpg)

</details>

```JS
function Foo(y) {
  this.y = y;
}
Foo.prototype.x = 10;
Foo.prototype.calculate = function (z) {
  return this.x + this.y + z;
};
let b = new Foo(20);
let c = new Foo(30);
b.calculate(30); // 60
c.calculate(40); // 80

console.log(
  b.__proto__ === Foo.prototype, // true
  c.__proto__ === Foo.prototype, // true
    b.constructor === Foo, // true
    c.constructor === Foo, // true
    Foo.prototype.constructor === Foo, // true
      b.calculate === b.__proto__.calculate, // true
      b.__proto__.calculate === Foo.prototype.calculate // true
);
```

![](http://dmitrysoshnikov.com/wp-content/uploads/constructor-proto-chain.png)

- Каждый конструктор имеет специальное свойство: `prototype`
- Каждый объект созданный конструктором содержит ссылку на `prototype` своего конструктора, эта ссылка хранится в свойстве `__proto__`.
- Сначала поиск свойства осуществляется в объекте, если оно не найдено, то поиск продолжается в цепочке прототипов.

Примечания:  
Всё, кроме примитивов - объекты  
Функции - это вызываемые объекты  
Конструкторы - функции которые используются вместе с оператором new и предназначены для создания и инициализации новых объектов  
Цепочка прототипов - это конечная цепочка объектов, которая используется для реализации наследования и общих свойств.  
https://www.youtube.com/watch?v=0vs6WkNyzec  
https://www.youtube.com/watch?v=42ihcHT-jfM

http://dmitrysoshnikov.com/ecmascript/javascript-the-core/ (best)

https://techshowers.wordpress.com/2013/07/01/javascript-prototype-vs-__proto__/  
https://stackoverflow.com/questions/9959727/proto-vs-prototype-in-javascript  
http://qaru.site/questions/26391/good-example-of-javascripts-prototype-based-inheritance
https://learn.javascript.ru/new-prototype

<details> 
  
![](http://risovach.ru/upload/2016/01/mem/klichko_103711688_orig_.jpg)
</details>

---

### 11. How to create an object without a prototype?

Как создать объект без прототипа:

- Для этого можно просто создать объект {}.

```JS
const objectFree = Object.create(null)
console.log('objectFree :', objectFree);

let empty = {};
console.log(empty.constructor);
empty;
```

Разные способы создания объектов:

- Литеральная нотация

```JS
Man = {
    id : 1,
    name : "Сеня",
    drinkingBeer : true
}
```

- Оператор new или {}

```JS
// let myCar = new Object(); // так делать плохо
let myCar = {}; // а так хорошо
myCar.make = "Ford";
myCar.model = "Mustang";
myCar.year = 1969;
```

- Ассоциативные массивы

```JS
let person = {};
person['firstName'] = 'Вася'; // то же что и person.name = 'Вася'
person['lastName'] = 'Васильев';
```

- Конструкторы объектов

```JS
function Man(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
  let phrase = "Привет";
  function getFullName() {
    return firstName + " " + lastName;
  }
  this.sayHi = () => {
    let say = phrase + ", " + getFullName();
    return say;
  }
}
let firstFriend = new Man('Иван', 'Иванович');
console.log(firstFriend);
let secondFriend = new Man('Петр', 'Петрович');
console.log(secondFriend);
console.log(secondFriend.sayHi()); // Привет, Петр Петрович
```

http://adripofjavascript.com/blog/drips/creating-objects-without-prototypes.html

https://habr.com/ru/post/17613/  
https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Working_with_Objects  
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create
https://metanit.com/web/javascript/4.5.php
https://metanit.com/web/javascript/4.1.php

```html
<body>
  <script>
    document.write(`<h1> Первый этап </h1>`);
    const animal = {
      say() {
        document.write(`<h2> voice ${this.voice} </h2>`);
      }
    };
    const dog = {
      name: "dog",
      voice: "woof"
    };
    Object.setPrototypeOf(dog, animal);
    const cat = {
      name: "cat",
      voice: "meaw"
    };
    Object.setPrototypeOf(cat, animal);
    cat.say();
    dog.say();
  </script>

  <script>
    document.write(`<h1> Второй этап через Object.create() </h1>`);
    const animal_2 = {
      say() {
        document.write(`<h2> voice  ${this.voice} </h2>`);
      }
    };

    const dog_2 = Object.create(animal_2);
    dog_2.name = "dog";
    dog_2.voice = "woof";

    const cat_2 = Object.create(animal_2);
    cat_2.name = "dog";
    cat_2.voice = "meaw";

    cat_2.say();
    dog_2.say();
  </script>

  <script>
    document.write(`<h1> Третий этап выносим логику </h1>`);
    const animal_3 = {
      say() {
        document.write(`<h2> voice  ${this.voice} </h2>`);
      }
    };

    function animalConstructor(name, voice) {
      const resault = Object.create(animal_3);
      resault.name = name;
      resault.voice = voice;
      return resault;
    }
    const dog_3 = animalConstructor("dog", "woof");
    const cat_3 = animalConstructor("cat", "meaw");

    cat_3.say();
    dog_3.say();
  </script>

  <script>
    document.write(`<h1> Четвертый используем new </h1>`);

    function Animal(name, voice) {
      this.name = name;
      this.voice = voice;
    }
    Animal.prototype.say = function() {
      document.write(`<h2> ${this.name} voice ${this.voice} </h2>`);
    };

    const dog_4 = new Animal("dog", "woof");
    const cat_4 = new Animal("cat", "meaw");

    cat_4.say();
    dog_4.say();
  </script>

  <script>
    const objectFree = Object.create(null); // создаст объект без прототипа
    console.log("objectFree :", objectFree);
  </script>

  <script>
    document.write(`<h1> переписываем всё через класс </h1>`);
    class Animal_5 {
      constructor(name, voice) {
        this.name = name;
        this.voice = voice;
      }
      say() {
        document.write(`<h2> ${this.name} voice ${this.voice} </h2>`);
      }
    }
    class Bird extends Animal_5 {
      constructor(name, voice) {
        super(name, voice);
        super.say(); // можем вызвать метод родителя
      }
      // новый метод
      canFly() {
        document.write(`<h2> Птица может летать </h2>`);
      }
      // переопределение метода
      say() {
        document.write(`<h2> Прицы не любят разговаривать </h2>`);
      }
    }
    const duck = new Bird("Утка", "кря-кря");
    duck.say();
    duck.canFly();
  </script>
</body>
```

---

### 12. Array methods that loop over the elements.

Методы массива, которые зацикливаются на элементах (который перебирают элементы).

Методы массива:
https://learn.javascript.ru/array-iteration  
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array

[[].forEach()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) выполняет указанную функцию для каждого элемента в массиве.

```JS
const copyArr = [];
['a', 'b', 'c'].forEach((item) => copyArr.push(item));
console.log(copyArr);
```

[[].map()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map) создаёт новый массив с результатом для каждого элемента массива.

```JS
const arr = [1, 2, 3].map((item) => item * 2);
console.log(arr);
```

[[].every()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/every) проверить все элементы на условие

```JS
const isBigEnough = (item) => item >= 10;
[12, 5, 8, 130, 44].every(isBigEnough);   // false
[12, 54, 18, 130, 44].every(isBigEnough); // true
```

[[].reduce()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce) - может многое, сумм, мин/макс, {что_захочешь}

```JS
const total = [1, 3, 2].reduce((acc, cur) => a + b);
console.log(total); // 6
const max = [1, 3, 2].reduce((prev, cur) => prev < cur ? cur : prev, 0);
console.log(max); // 3
const min = [1, 3, 2].reduce((prev, cur) => prev > cur ? cur : prev, -10);
console.log(min); // -10
```

[[].find()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/find) возвращает значение **первого** найденного в массиве элемента по условию или undefined.

```JS
const find = [1, 3, 2].find((item) => item >= 2);
console.log(find); // 3
```

[[].filter()](https://learn.javascript.ru/array-iteration#filter) - вернет фильтрованный массив

```js
const filter = [1, 3, 2, 5].filter(item => item >= 3);
console.log(filter); // [3, 5]
```

[[].sort()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) - весёлая сортировка

```js
const sort = [4, 2, 5, 1, 3].sort((a, b) => a - b);
console.log(sort); // [1, 2, 3, 4, 5]
const sort = [4, 2, 5, 1, 3].sort((a, b) => b - a);
console.log(sort); // [5, 4, 3, 2, 1]
```

---

### 13. “hello world”.repeating(3) -> hello world hello world hello world. How to implement?

```JS
function repeat(str, iteration){
  let arr = new Array(iteration);
  arr.fill(str);
  return arr.join(" ");
}
console.log(repeat("hello world", 3)); // 'hello world hello world hello world'
```

```JS
// самое короткое решение
"hello world ".repeat(3).slice(0, -1);
```

```JS
// можно и так
    function repeat(str = "hello world", iteration = 3) {
      let newStr = str;
      for (let i = 1; i < iteration; i++) {
        newStr += (' ' + str);
      }
      return newStr;
    }
    console.log(repeat());
    console.log(repeat('a'));
```

http://studyjavascript.blogspot.com/2019/03/hello-worldrepeating3.html

---

### 14. Browser events. Browser default actions abortion.

События браузера. Отмена действий браузера по умолчанию.

- Событие – это сигнал от браузера о том, что что-то произошло.

Основные:  
<b>События мыши:</b> click, mouseover, mousedown... https://developer.mozilla.org/ru/docs/Web/API/MouseEvent  
<b>Клавиатурные события:</b> keydown, keyup... https://developer.mozilla.org/ru/docs/Web/API/KeyboardEvent  
<b>События документа:</b> load, beforeunload, unload...  
<b>События на элементах:</b> submit, focus...

Список событий - https://www.w3schools.com/jsref/dom_obj_event.asp  
Events list from MDN - https://developer.mozilla.org/en-US/docs/Web/API/Event

https://learn.javascript.ru/introduction-browser-events  
https://developer.mozilla.org/ru/docs/Web/Events

- Действия браузера по умолчанию и как их отменить:

Многие события автоматически влекут за собой действие браузера.  
Например:  
Клик по ссылке инициирует переход на новый URL.  
Нажатие на кнопку «отправить» в форме – отсылку ее на сервер.  
Двойной клик на тексте – инициирует его выделение.

<b>Есть два способа отменить действие браузера:</b>  
Основной способ – это воспользоваться объектом события. Для отмены действия браузера существует стандартный метод <b>event.preventDefault()</b>.  
Если же обработчик назначен через onсобытие (не через addEventListener), то можно просто вернуть false из обработчика.

Подробно про default browser action - https://learn.javascript.ru/default-browser-action  
Event.preventDefault() - https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault

---

### 15. Event bubbling and event capturing.

Всплытие и захват (перехват) событий

Всплытие:

```html
<form onclick="alert('form')">
  FORM
  <div onclick="alert('div')">
    DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>
<!-- 
P → DIV → FORM (bubbling)
Событие всплывает наверх начиная с элемента на котором происходит действие.
-->
```

Перехват событий, пример:  
FORM → DIV → P (Capturing)  
(target)  
P → DIV → FORM (bubbling)

```html
<form>
  FORM
  <div>
    DIV
    <p>P</p>
  </div>
</form>
<script>
  for (let elem of document.querySelectorAll("*")) {
    elem.addEventListener(
      "click",
      e => alert(`Capturing: ${elem.tagName}`),
      true
    );
    elem.addEventListener("click", e => alert(`Bubbling: ${elem.tagName}`));
  }
</script>
```

Отмена действий по умолчанию - https://learn.javascript.ru/default-browser-action

```js
<a href="/" onclick="return false">Нажми здесь</a>
<a href="/" onclick="event.preventDefault()">здесь</a>
<button onclick="event.stopPropagation()">Кликни</button>
// остановить всплытие
<button onclick="event.stopImmediatePropagation()">Кликни</button>
// остановить всплытие и обработку событий
```

https://javascript.info/bubbling-and-capturing#capturing

Перехват событий будет происходит в три этапа:
Погружение - Цель - Всплытие
<img src="https://www.w3.org/TR/DOM-Level-3-Events/images/eventflow.svg" width="400" height="" alt="">

Метод EventTarget.addEventListener() - https://developer.mozilla.org/ru/docs/Web/API/EventTarget/addEventListener

http://code.mu/books/javascript/dom/prodvinutaya-rabota-s-objektom-event-na-javascript.html (best)  
https://habr.com/ru/post/126471/  
https://learn.javascript.ru/event-bubbling  
https://stackoverflow.com/questions/4616694/what-is-event-bubbling-and-capturing

---

### 16. Event delegation. Example.

Событие делегирования. Пример.  
Делегирование событий в javascript – это возможность обрабатывать дочерние элементы через один родительский.

```HTML
  <ul id="ul">
    <li>пункт 1</li>
    <li>пункт 2</li>
    <li>пункт 3</li>
    <li>пункт 4</li>
    <li>пункт 5</li>
  </ul>

  <script>
    let ul = document.getElementById('ul');
    ul.addEventListener('click', addText);
    function addText() {
      event.target.innerHTML = event.target.innerHTML + ' !';
    }
  </script>
```

```HTML
<!-- Делегирование событий и остановка
event.preventDefault();
event.stopPropagation();
-->
<div onclick="alert('div')">
    <ul onclick="alert(event.target.title); event.stopPropagation();">
        <li title="One">One</li>
        <li title="Two">Two</li>
        <li title="Three">Three</li>
    </ul>
</div>
```

http://code.mu/books/javascript/dom/prodvinutaya-rabota-s-objektom-event-na-javascript.html (best)  
[getElementById()](https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById)  
[addEventListener()](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)

http://qaru.site/questions/172/what-is-dom-event-delegation  
https://learn.javascript.ru/event-delegation

https://davidwalsh.name/event-delegate  
https://stackoverflow.com/questions/1687296/what-is-dom-event-delegation

---

### 17. Write a function F so new F === F

```JS
function F() {
  return F;
}
new F() === F // true
```

<details> 
<summary>Автор этой функции ↴</summary>
  
![](http://zw.ciit.zp.ua/zwimg/7/79/Gg_58uWnFwY.jpg)
</details>

---

### 18. Function.prototype.bind polyfill.

надо разбираться

возможно тут:  
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Polyfill
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/bind

---

### 19. Object.create polyfill.

надо разбираться

возможно тут:  
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create  
https://learn.javascript.ru/new-prototype - не для этого, но возможно пригодится

---

### 20. Event loop.

цикл событий или же событийный цикл  
надо разбираться

возможно тут:  
https://www.youtube.com/watch?v=aUigiwN0NEw - Event Loop in the browser Javascript

[JavaScript event loop в картинках](https://medium.com/@pavelbely/javascript-event-loop-%D0%B2-%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B0%D1%85-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1-a19e4d99f242)

---

### 21. Promises.

надо разбираться  
возможно тут:  
https://learn.javascript.ru/promise
https://medium.com/devschacht/%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D1%82%D0%B5%D0%BA%D1%82%D1%80%D0%B5%D0%B9%D1%81%D1%8B-%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-await-%D0%BF%D0%BE%D0%B1%D0%B5%D0%B6%D0%B4%D0%B0%D0%B5%D1%82-then-6a5e6dad0584

```JS
// Нативные промисы (es6)
const a = () => {
  b().then(() => c());
};

// async/await (es7)
const a = async () => {
  await b();
  c();
};
```

- box-sizing: border-box | content-box :

![](https://www.tutorialrepublic.com/lib/images/css-box-model.jpg)
![](https://learn.javascript.ru/article/box-sizing/border-box.svg)
